#!/usr/bin/env zsh

if (( ${+PROJECT_DIR} )); then
   local project_dir=${PROJECT_DIR}
else
   local project_dir=$(pwd)
fi
RUN=${project_dir}/run
SENDER=rtpsctp/rtpsctpsend
RECEIVER=rtpsctp/rtpsctprecv
TMP_DIR=/tmp
TMP_RES_DIR=${TMP_DIR}/gst-sctp-results

TARGET=${project_dir}/build
TARGET_DEBUG=${project_dir}/build_debug

DEBUG_SENDER="sctpsink:4,rtpsctpsend:4"
DEBUG_RECEIVER="sctpsrc:4,rtpsctprecv:4"


TRAPINT() {
   print "Caught SIGINT, aborting."
   kill ${${(v)jobstates##*:*:}%=*}
   ${=receiver_root} killall rtpsctprecv
   ssh root@${ip_sender} 'killall rtpsctpsend'
   wait

   [[ ! ${+verbose[1]} ]] && set +x
   rmdir .receiver_running.lok
   rmdir .receiver_start.lok
   exit
}

# TRAPEXIT() {
   # return -1
# }

zparseopts -D -E -- R=remote v=verbose n:=num_runs d=debug -ntp=ntp W=nowrite

if (( ${+verbose[1]} )); then
   set -x
fi

if (( ${+debug[1]} )); then
     DEBUG_SENDER="3,GST_REGISTRY:3,task:3,gstutils:5,GST_STATES:2,structure:3,basesink:3,rtpsctpsend:6,rtpbasepayload:3,rtpvrawpay:3,sctpsink:6,sctputils:4,usrsctpsnd:8,multiudpsink:2"
   DEBUG_RECEIVER="3,GST_REGISTRY:3,task:3,gstutils:5,GST_STATES:2,basesrc:3,pushsrc:5,rtpbasedepayload:5,rtpjitterbuffer:3,rtpsctprecv:5,sctpsrc:5,sctputils:4,usrsctprecv:8,udpsrc:3"
   TARGET=$TARGET_DEBUG
fi

if (( ${+remote[1]} )); then
   receiver_root="ssh root@${ip_receiver}"
   receiver_run="ssh ibk@${ip_receiver}"
else
   receiver_root=sudo
   receiver_run=""
fi

local ip_sender=${IP_SENDER:-192.168.153.132}
local ip_receiver=${IP_RECEIVER:-192.168.153.135}
ip a | grep -q ${ip_receiver}
if (( $? )); then
   echo "wrong receiver ip"
   exit
fi

local phy1=${PHY1:-ens37}
local phy2=${PHY2:-ens38}

local deadline=${DEADLINE:-450}
local num=${NUM:-2000}
local padding=${PADDING:-60}
local runs=${num_runs[2]:-1}

if (( ${+VARIANT} )); then
   local -a testing_variants=(${=VARIANT})
else
   # typeset -a testing_variants
   local -a testing_variants=(udp single cmt dupl dpr)
fi
if (( ${+DELAY} )); then
   local -a testing_delay=(${=DELAY})
else
   # typeset -a testing_delay
   local -a testing_delay=(5 20 40 60 80 100)
fi
if (( ${+DROP} )); then
   local -a testing_drop=(${=DROP})
else
   # typeset -a testing_drop
   local -a testing_drop=(0 1 2 3 4 5 6 7 8 9 10 12 15 20)
fi

run_date=$(date +%F_%R)
if (( ! ${+nowrite[1]} )); then
   ${=receiver_run} mkdir -p ${project_dir}/results/${run_date}
   ${=receiver_run} cat > ${project_dir}/results/${run_date}/experiments_config <<EOL
project_dir=${project_dir}
ip_sender=${ip_sender}
ip_receiver=${ip_receiver}
phy1=${phy1}
phy2=${phy2}
variant=${testing_variants}
delay_on_link=${testing_delay}
deadline=${deadline}
num_frames=${num}
drop_rate=${testing_drop}
padding=${padding}
runs=${runs}
EOL
fi

for variant in ${testing_variants}; do
   for delay in ${testing_delay}; do
      for drop in ${testing_drop}; do
         run_id=${variant}_${delay}ms_${drop}d_${deadline}D_${num}n

         ${=receiver_run} rm -rf $TMP_RES_DIR
         ${=receiver_run} mkdir -p $TMP_RES_DIR
         ssh root@${ip_sender} "rm -rf ${TMP_RES_DIR} && mkdir -p ${TMP_RES_DIR}"

         echo "\033[0;31msetting delay= ${delay} drop_rate= ${drop}\033[0m"
         ssh root@${ip_sender} "tc qdisc replace dev $phy1 root netem loss ${drop}% 25% delay ${delay}ms"
         ssh root@${ip_sender} "tc qdisc replace dev $phy2 root netem loss ${drop}% 25% delay ${delay}ms"
         ${=receiver_root} tc qdisc replace dev $phy1 root netem loss ${drop}% 25% delay ${delay}ms
         ${=receiver_root} tc qdisc replace dev $phy2 root netem loss ${drop}% 25% delay ${delay}ms

         if (( ${+ntp[1]} )); then
            ssh root@${ip_sender} sudo systemctl stop ntpd.service
            ssh root@${ip_sender} sudo ntpdate ${ip_receiver}
            if (( $? )); then
               echo "\033[0;31mNTP failed\033[0m"
            fi
            ssh root@${ip_sender} sudo systemctl start ntpd.service
         fi

         count=1
         while (( $count <= $runs )) ; do
            local systime=$(date +%s)
            echo -e "\033[0;31mstarting variant ${variant} with delay= ${delay} drop_rate= ${drop}\033[0m"

            # sync so the receiver realy starts first (only for UDP)
            [[ $variant == "udp" ]] && mkdir .receiver_start.lok

            (
            echo -e "\033[0;31m------- Receiver starting\033[0m"

            if (( ! ${+nowrite[1]} )); then
               cp /sys/class/net/${phy1}/statistics/tx_bytes ${TMP_RES_DIR}/receiver_${phy1}_tx_bytes_pre_${count}
               cp /sys/class/net/${phy1}/statistics/rx_bytes ${TMP_RES_DIR}/receiver_${phy1}_rx_bytes_pre_${count}
               cp /sys/class/net/${phy2}/statistics/tx_bytes ${TMP_RES_DIR}/receiver_${phy2}_tx_bytes_pre_${count}
               cp /sys/class/net/${phy2}/statistics/rx_bytes ${TMP_RES_DIR}/receiver_${phy2}_rx_bytes_pre_${count}
            fi

            [[ $variant == "udp" ]] && rmdir .receiver_start.lok
            [[ $variant != "udp" ]] && mkdir .receiver_running.lok

            ${=receiver_root} PROJECT_DIR=${project_dir} $RUN $TARGET $RECEIVER -d $DEBUG_RECEIVER -V $variant -D $deadline -T $systime --delay $delay --padding $padding | tee ${TMP_RES_DIR}/out_receiver_${count}

            [[ $variant != "udp" ]] && rmdir .receiver_running.lok

            if (( ! ${+nowrite[1]} )); then
               cp /sys/class/net/${phy1}/statistics/tx_bytes ${TMP_RES_DIR}/receiver_${phy1}_tx_bytes_post_${count}
               cp /sys/class/net/${phy1}/statistics/rx_bytes ${TMP_RES_DIR}/receiver_${phy1}_rx_bytes_post_${count}
               cp /sys/class/net/${phy2}/statistics/tx_bytes ${TMP_RES_DIR}/receiver_${phy2}_tx_bytes_post_${count}
               cp /sys/class/net/${phy2}/statistics/rx_bytes ${TMP_RES_DIR}/receiver_${phy2}_rx_bytes_post_${count}
            fi

            echo -e "\033[0;32m------- Receiver finished\033[0m"
            ) &

            (

            if (( ! ${+nowrite[1]} )); then
               scp -q root@${ip_sender}:/sys/class/net/${phy1}/statistics/tx_bytes ${TMP_RES_DIR}/sender_${phy1}_tx_bytes_pre_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy1}/statistics/rx_bytes ${TMP_RES_DIR}/sender_${phy1}_rx_bytes_pre_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy2}/statistics/tx_bytes ${TMP_RES_DIR}/sender_${phy2}_tx_bytes_pre_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy2}/statistics/rx_bytes ${TMP_RES_DIR}/sender_${phy2}_rx_bytes_pre_${count}
            fi

            while [[ $variant == "udp" ]] && [ -d .receiver_start.lok ]; do sleep 1; done
            # [ $variant == "udp" ]] && echo "receiver unlocked starting sender"
            echo -e "\033[0;31m------- Sender starting\033[0m"

            ssh root@${ip_sender} "PROJECT_DIR=${project_dir} IP_RECEIVER=${ip_receiver} $RUN $TARGET $SENDER -d $DEBUG_SENDER -V $variant -D $deadline -n $num --delay $delay --padding $padding -T $systime" | tee ${TMP_RES_DIR}/out_sender_${count}

            local c=0
            while [[ $variant != "udp" ]] && [ -d .receiver_running.lok ]; do
               sleep 1
               (( c++ ))
               if (( $c >= 30 )); then
                  ${=receiver_root} killall rtpsctprecv
                  touch ${TMP_RES_DIR}/receiver_killed_${count}
                  break
               fi
            done

            if (( ! ${+nowrite[1]} )); then
               scp -q root@${ip_sender}:/sys/class/net/${phy1}/statistics/tx_bytes ${TMP_RES_DIR}/sender_${phy1}_tx_bytes_post_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy1}/statistics/rx_bytes ${TMP_RES_DIR}/sender_${phy1}_rx_bytes_post_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy2}/statistics/tx_bytes ${TMP_RES_DIR}/sender_${phy2}_tx_bytes_post_${count}
               scp -q root@${ip_sender}:/sys/class/net/${phy2}/statistics/rx_bytes ${TMP_RES_DIR}/sender_${phy2}_rx_bytes_post_${count}
            fi
            echo -e "\033[0;32m------- Sender finished\033[0m"
            ) &

            wait
            echo "\033[0;32mrun $count finished ${run_id}\033[0m"
            if (( ! ${+nowrite[1]} )); then
               ${=receiver_run} mv ${TMP_RES_DIR}/experiment_trace_in.csv ${TMP_RES_DIR}/experiment_trace_in_${count}.csv
               ${=receiver_run} mv ${TMP_RES_DIR}/experiment_trace_out.csv ${TMP_RES_DIR}/experiment_trace_out_${count}.csv
               ${=receiver_run} mv ${TMP_RES_DIR}/usrsctp_stats_receiver ${TMP_RES_DIR}/usrsctp_stats_receiver_${count}
               scp -q root@${ip_sender}:${TMP_RES_DIR}/usrsctp_stats_sender ${TMP_RES_DIR}/usrsctp_stats_sender_${count}
            fi
            (( count++ ))
         done

         if (( ! ${+nowrite[1]} )); then
            echo "\033[0;32mall runs finished ID: ${run_id} >> writing results to ${project_dir}/results/${run_date}/${run_id}\033[0m"
            ${=receiver_run} mkdir -p ${project_dir}/results/${run_date}/${run_id}
            ${=receiver_run} mv ${TMP_RES_DIR}/* ${project_dir}/results/${run_date}/${run_id}
            ${=receiver_run} cat > ${project_dir}/results/${run_date}/${run_id}/run_config <<EOL
project_dir=${project_dir}
ip_sender=${ip_sender}
ip_receiver=${ip_receiver}
phy1=${phy1}
phy2=${phy2}
variant=${variant}
delay_on_link=${delay}
deadline=${deadline}
num_frames=${num}
drop_rate=${drop}
padding=${padding}
runs=${runs}
EOL
         fi
         sleep 2

      done # drop
   done # delay
done # variant

[[ ! ${+verbose[1]} ]] && set +x
rmdir .receiver_running.lok
rmdir .receiver_start.lok
exit

